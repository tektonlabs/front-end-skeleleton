# Front End Skeleton
This repository contains the files necessary to run the Front End stack of any application. It also has tasks to support a nice development workflow as well as tasks to build optimized code for production. It is built on top of ES6, SCSS, React and npm as the task runner. You'll find a list of the packages and scripts we're using in the **package.json**.

In order to use it, you'll first need to install an updated version of node.js(and npm). You can check if you already have it installed and the version by running **node -v** through a CLI. I recommend having a version above 4.0.0 to have things running smoothly.

Here is a list of the most useful npm tasks you can run and what they do:
* ```npm run build``` is used to compile all the source scss, es6 and vendor js into optimized, production ready code. It's a simple way of calling  ```npm run build-vendor-js```, ```npm run build-js``` and ```npm run build-css``` in a single command.
* ```npm run build-vendor-js``` is used to build the vendor js file. It currently takes **react**, **react-dom** and **ramda** as its source. All the commands run by this task can be found at the file './bin/build-vendor-js'.
* ```npm run build-js``` is used to compile the source es6. All the commands run by this task can be found at the file './bin/build-js'.
* ```npm run build-css``` is used to build the optimized css. All the commands run by this task can be found at the file './bin/build-css'.
* ```npm run start-dev``` is what you will want to run to start coding. It starts monitoring for file changes in your source scss and es6, rebuilds the output files and injects the new css to your browser, and in the case of the js changes it refreshes the browser. This task runs ```npm run watch``` and ```npm run sync``` in parallel.
* ```npm run sync``` synchronizes file changes on the compiled css and js with your browser so that changes are reflected automatically. In order for this to work you have to add an async script before the closing body tag in your HTML. This script has already been added to the **index.html** as an example. Also each time you run the task, the console outputs the script so that you can copy and paste it into your HTML.

## Using it in your projects
Just copy these folders in the root level of your project and organize as needed. For example if your project has only one public folder, you can change the paths where the compiled files will be generated by replacing the urls in the bin folder. Just find and replace **'build'** with **'PATH/build'**. Keep the **build** folder to avoid any problem since the folder is built and regerated each time.

Replacing the **src** folder might be a little trickier but it can be done using the same strategy. Just move the folders as needed and find and replace the paths in the **bin** folder.

## General outlines
* If you want to add a new vendor file, you'll need to follow some steps.
   * Let's say you want to add jquery, you'll first need to install it through npm. The command for doing this is ```npm i --save PACKAGE_NAME```. In this case it'd be ```npm install jquery```. You can find a list of all the packages available at [npm](https://www.npmjs.com/).
   * After that you'll need to add **jquery** to the **build-vendor-js** task in order for it to be available for importing in your source files. You can do this by going into the **'./bin/build-vendor-js'** file and adding it as a require option with ```-r jquery \```.
   * Then you just need to tell the **build-js** and **watch-js** tasks that you're externally importing the vendor packages in another file so they don't get duplicated and that's it.
*  There is an example on how to import jquery and an scaffold to start working with it in the **'./src/js/libs'** folder since it's one of the most common libraries.
*  Ramda has been added to the vendor. It's a library with functional utilities that are automatically curried. It has proven to be much more convenient to use than lodash or underscore.js with its iteratee-first data-last methods. You can change it for another one you feel more familiar with, although I recommend trying it. Another library that is going this way is an instance of lodash called lodash/fp.

## Guidelines and Conventions
### CSS and SCSS
When working with css, things can get messy pretty quickly since every class definition exists on a global scope. You have to be very careful with how you are naming your classes so you can avoid collisions. There are some general rules and class naming conventions that have been really helpful and are pretty easy to follow. We will write these using scss syntax but they are perfectly applicable to regular css.
* ##### Avoid using IDs

   Using IDs is bad in most cases because it creates an specificity problem. It might indirectly override some styles and then people start using **!important** or creating more specificity just to circunvent a problem they shouldn't have had in the first place. Of course there are situations where you will need them to do things like creating anchors or to target the element with JavaScript so just use your criteria.

* ##### Mobile First Responsive Web Design
   This is a methodology for the development of responsive web user interfaces. In essense it's really simple, think about mobile first, then scale your design to a desktop view. By doing this you achieve a cleaner document structure, code and most importantly interfaces.

   To do this, our non media query styles will target the minimum resolution we're contemplating for the project. So if our project contemplates 320px as it's minimum accepted resolution, start working for 320px with your regular styles. You'll notice that the design flows much better from mobile to desktop. On the contrary if we were working desktop first and then tried to view that on mobile, most likely it would look really bad.

   Working this way also reduces our lines of code. Most times on desktop, since we have more room to do things like using special alignments or having 3 or 4 items per row, we have to add properties like ```float```, ```inline-block``` or ```flex```. If we started working on the desktop view first, when we get to mobile we would have to overwrite those properties with ```block``` as in most mobile views the limited space only allows you to have one element per row. What's funny is that those elements were block elements by default, but because we started working on the desktop view first we had to change that property. With a mobile first approach, we would just define that when the resolution hits certain breakpoint, some properties are added, but those properties won't impact mobile views and won't create unexpected behaviour mostly present when using a mobile.

   In scss we have a pretty convenient way of adding media queries using a mixin. It's really useful for maintenance because all the styles for the selector are defined in the same place instead of having multiple instances of the selector accross multiple media queries. The mixin looks like this:

   ```scss
    @mixin breakpoint($point) {
        @if $point == small {
            @media (min-width: $small-bp) { @content; }
        }
        @else if $point == medium {
            @media (min-width: $medium-bp) { @content; }
        }
        @else if $point == large {
            @media (min-width: $large-bp) { @content; }
        }
        @else if $point == xlarge {
            @media (min-width: $xlarge-bp) { @content; }
        }
    }
   ```

   You can change the breakpoints in the **_variables.scss** file. They are defined in **ems** because they are the right unit for the job. You can read more about it in this [cloudfour article](http://blog.cloudfour.com/the-ems-have-it-proportional-media-queries-ftw/).

   In your styles you would use the mixin this way:
   ```scss
    .class-name {
        property: value;
        property: value;
        @include breakpoint(medium) {
            property: value;
        }
        @include breakpoint(large) {
            property: value;
        }
    }
   ```

* ##### Thinking in objects

   Using selectors that represent objects puts them in a direction to be more reusable and easy to identify or associate with a component in the view. Start using nouns like button, user-card, header, product, etc.

* ##### Avoid nesting selectors

   Nesting selectors creates another specificity problem and also leads to unintended side effects. Let's say we have something like this:

   ```scss
    .post {
        margin: 20px;
        .title {
            font-size: 18px;
            color: #b06010;
            font-weight: 400;
        }
    }
   ```

   Defining the styles for an object this way looks fine, but what if I had already defined a ```.title``` class before at the root level that had it's ```line-height``` and other bunch of properties already set to something that breaks the design of a post's title. Then I would have to overwrite each of them unnecessarily or have styles split accross different files for the same object which is bad for maintainability. It's a better pattern to have them defined this way.

   ```scss
    .post {
        margin: 20px;
    }

    .post-title {
        font-size: 18px;
        color: #b06010;
        font-weight: 400;
    }
   ```

   Adding this kind of prefix that creates some sort of parent-child relationship, stops any styles from bleeding inside the object. It also looks cleaner and it's easier to maintain. As a general rule, try to not exceed 3 levels of nesting in your css.

   Another pattern to avoid nesting is using the plural name of the object as a class name to define its container. Then we would end up with something like:

   ```scss
    .posts {
        width: 100%;
        padding: 10px 20px;
    }

    .post {
        margin: 20px;
    }

    .post-title {
        font-size: 18px;
        color: #b06010;
        font-weight: 400;
    }
   ```
* ##### Subclassing Objects

   In object-oriented systems, subclassing is useful for inheriting properties of another object. We can do the same in css by declaring a generic class and making other classes extend from it. I always use this for setting up my application icons like this:

   ```scss
    %icon {
        display: inline-block;
        background-repeat: no-repeat;
        background-position: 50%;
        background-size: auto 100%;
        vertical-align: middle;
    }

    .close-icon {
        @extend %icon;
        background-image: url("close-icon.svg");
        width: 15px;
        height: 15px;
    }
   ```

   Then in your html you would just use it like ```<span class="close-icon"></span>```. When extending from a placeholder or another class, I always put the generic name at the end, I think it looks cleaner.

* ##### Modifiers
   Modifiers are a way of changing or adding new properties to an element according to some sort of context. This context may be given by different things like a state or just defined by an element being displayed on a specific section. Here is a basic example with a button:

   ```scss
   .button {
        color: white;
        font-size: 14px;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        background-color: #81c784;
        cursor: pointer;
        &:focus {
            outline: none;
        }
        &.is-disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        &.has-icon{
            padding-left: 45px;
            background-size: 25px 25px;
            background-repeat: no-repeat;
            background-position: 10px 50%;
        }
    }

    .facebook-button{
        @extend .button;
        background-color: #3b5998;
        background-image: url('fb-icon.svg');
    }
   ```

   Now it would be easy for us to declare a button like this: ```<button class="facebook-button has-icon">REGISTER</button>``` and just add the disabled class when necessary. This kind of modularity is really convenient and makes maintenance  a breeze.

   As you can see, the convention to use here is ```.prefix-adjective``` for most cases, or simply ```.adjective``` when it's a singular property we're dealing with. The prefixes **is**, **has** and **in** are the ones I find the most useful and the ones I'm limiting myself to use because having too many sounds unnecessary and defeats the purpose of having conventions.

   You can use the ```.adjective``` form to describe simpler property modifications. Modifiers like ```.big```, ```.scrollable``` or ```.visible``` at most would change one or two properties. The ```.is-adjective``` form is also used a lot and it describes an state for the element. Common states are ```.is-disabled```, ```.is-active```. Then we have the ```.has-adjective``` modifier that is used when you want to change an element's properties because of it having an specific child or special content for that instance. For example we could have the modifiers ```.has-icon```, ```.has-title``` or ```.has-image``` in this category. I have also used modifiers like ```.in-section``` that changes an element's look and feel whether it is displayed on a specific section, e.g. ```.in-header```. You may find more combinations that fit different use cases, just try to restrain yourself from using too many.

* ##### SCSS formatting
   This is the formatting we're using for applications and we believe it's really clean and organized.
   ```scss
    .class-name { // Multiple words are separated by dashes
        @extend %placeholder; // First extend from placeholders
        @extend .class; // Then extend from classes
        @include mixin(params...); // Calls to mixins
        property: value; // Leave a blank space after the ":"
        property: value;
        &:state { // Set properties for different element states
            property: value;
        }
        &.modifier-name { // Properties for modifiers come next
            property: value;
        }
        @include breakpoint(large) { // Add mediaquery mixins from min to max
            property: value;
        }
        .child-class-name { // Finally add properties for nested children
            property: value;
            ...
        }
    }

    .class-name { // Selectors are separated by a line break
        property: value;
    }
   ```

## Final Words

I hope you find this project useful and that the documentation was easy to follow. Any feedback is greatly appreciated and I would love to hear about new conventions you use or anything you would like to add to the project. Thanks for reading.

##### Gianluca Candiotti